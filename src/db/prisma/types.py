# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# Profile types

class ProfileOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Profile create method"""
    email: Optional[_str]
    createdAt: datetime.datetime
    Reports: 'ReportCreateManyNestedWithoutRelationsInput'
    Predictions: 'PredictionCreateManyNestedWithoutRelationsInput'
    TriageNotes: 'TriageNoteCreateManyNestedWithoutRelationsInput'


class ProfileCreateInput(ProfileOptionalCreateInput):
    """Required arguments to the Profile create method"""
    userId: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ProfileOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Profile create method, without relations"""
    email: Optional[_str]
    createdAt: datetime.datetime


class ProfileCreateWithoutRelationsInput(ProfileOptionalCreateWithoutRelationsInput):
    """Required arguments to the Profile create method, without relations"""
    userId: _str


class ProfileCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ProfileCreateWithoutRelationsInput'
    connect: 'ProfileWhereUniqueInput'


class ProfileCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ProfileCreateWithoutRelationsInput', List['ProfileCreateWithoutRelationsInput']]
    connect: Union['ProfileWhereUniqueInput', List['ProfileWhereUniqueInput']]


_ProfileWhereUnique_userId_Input = TypedDict(
    '_ProfileWhereUnique_userId_Input',
    {
        'userId': '_str',
    },
    total=True
)

ProfileWhereUniqueInput = _ProfileWhereUnique_userId_Input


class ProfileUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    userId: _str
    email: Optional[_str]
    createdAt: datetime.datetime
    Reports: 'ReportUpdateManyWithoutRelationsInput'
    Predictions: 'PredictionUpdateManyWithoutRelationsInput'
    TriageNotes: 'TriageNoteUpdateManyWithoutRelationsInput'


class ProfileUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    userId: _str
    email: Optional[_str]
    createdAt: datetime.datetime


class ProfileUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ProfileCreateWithoutRelationsInput']
    connect: List['ProfileWhereUniqueInput']
    set: List['ProfileWhereUniqueInput']
    disconnect: List['ProfileWhereUniqueInput']
    delete: List['ProfileWhereUniqueInput']

    # TODO
    # update: List['ProfileUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ProfileUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ProfileScalarWhereInput']
    # upsert: List['ProfileUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['ProfileCreateOrConnectWithoutRelationsInput']


class ProfileUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ProfileCreateWithoutRelationsInput'
    connect: 'ProfileWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ProfileUpdateInput'
    # upsert: 'ProfileUpsertWithoutRelationsInput'
    # connectOrCreate: 'ProfileCreateOrConnectWithoutRelationsInput'


class ProfileUpsertInput(TypedDict):
    create: 'ProfileCreateInput'
    update: 'ProfileUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Profile_userId_OrderByInput = TypedDict(
    '_Profile_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Profile_email_OrderByInput = TypedDict(
    '_Profile_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Profile_createdAt_OrderByInput = TypedDict(
    '_Profile_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

ProfileOrderByInput = Union[
    '_Profile_userId_OrderByInput',
    '_Profile_email_OrderByInput',
    '_Profile_createdAt_OrderByInput',
]



# recursive Profile types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ProfileRelationFilter = TypedDict(
    'ProfileRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ProfileListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ProfileInclude(TypedDict, total=False):
    """Profile relational arguments"""
    Reports: Union[bool, 'FindManyReportArgsFromProfile']
    Predictions: Union[bool, 'FindManyPredictionArgsFromProfile']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromProfile']


    

class ProfileIncludeFromProfile(TypedDict, total=False):
    """Relational arguments for Profile"""
    Reports: Union[bool, 'FindManyReportArgsFromProfileRecursive1']
    Predictions: Union[bool, 'FindManyPredictionArgsFromProfileRecursive1']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromProfileRecursive1']


class ProfileIncludeFromProfileRecursive1(TypedDict, total=False):
    """Relational arguments for Profile"""
    Reports: Union[bool, 'FindManyReportArgsFromProfileRecursive2']
    Predictions: Union[bool, 'FindManyPredictionArgsFromProfileRecursive2']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromProfileRecursive2']


class ProfileIncludeFromProfileRecursive2(TypedDict, total=False):
    """Relational arguments for Profile"""
    Reports: Union[bool, 'FindManyReportArgsFromProfileRecursive3']
    Predictions: Union[bool, 'FindManyPredictionArgsFromProfileRecursive3']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromProfileRecursive3']


class ProfileIncludeFromProfileRecursive3(TypedDict, total=False):
    """Relational arguments for Profile"""
    Reports: Union[bool, 'FindManyReportArgsFromProfileRecursive4']
    Predictions: Union[bool, 'FindManyPredictionArgsFromProfileRecursive4']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromProfileRecursive4']


class ProfileIncludeFromProfileRecursive4(TypedDict, total=False):
    """Relational arguments for Profile"""

    

class ProfileArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'ProfileIncludeFromProfileRecursive1'


class ProfileArgsFromProfileRecursive1(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'ProfileIncludeFromProfileRecursive2'


class ProfileArgsFromProfileRecursive2(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'ProfileIncludeFromProfileRecursive3'


class ProfileArgsFromProfileRecursive3(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'ProfileIncludeFromProfileRecursive4'


class ProfileArgsFromProfileRecursive4(TypedDict, total=False):
    """Arguments for Profile"""
    
    

class FindManyProfileArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive1'


class FindManyProfileArgsFromProfileRecursive1(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive2'


class FindManyProfileArgsFromProfileRecursive2(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive3'


class FindManyProfileArgsFromProfileRecursive3(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive4'


class FindManyProfileArgsFromProfileRecursive4(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    
    

class ReportIncludeFromProfile(TypedDict, total=False):
    """Relational arguments for Profile"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromProfileRecursive1']
    Profile: Union[bool, 'ProfileArgsFromProfileRecursive1']


class ReportIncludeFromProfileRecursive1(TypedDict, total=False):
    """Relational arguments for Profile"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromProfileRecursive2']
    Profile: Union[bool, 'ProfileArgsFromProfileRecursive2']


class ReportIncludeFromProfileRecursive2(TypedDict, total=False):
    """Relational arguments for Profile"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromProfileRecursive3']
    Profile: Union[bool, 'ProfileArgsFromProfileRecursive3']


class ReportIncludeFromProfileRecursive3(TypedDict, total=False):
    """Relational arguments for Profile"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromProfileRecursive4']
    Profile: Union[bool, 'ProfileArgsFromProfileRecursive4']


class ReportIncludeFromProfileRecursive4(TypedDict, total=False):
    """Relational arguments for Profile"""

    

class ReportArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'ReportIncludeFromReportRecursive1'


class ReportArgsFromProfileRecursive1(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'ReportIncludeFromReportRecursive2'


class ReportArgsFromProfileRecursive2(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'ReportIncludeFromReportRecursive3'


class ReportArgsFromProfileRecursive3(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'ReportIncludeFromReportRecursive4'


class ReportArgsFromProfileRecursive4(TypedDict, total=False):
    """Arguments for Profile"""
    
    

class FindManyReportArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive1'


class FindManyReportArgsFromProfileRecursive1(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive2'


class FindManyReportArgsFromProfileRecursive2(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive3'


class FindManyReportArgsFromProfileRecursive3(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive4'


class FindManyReportArgsFromProfileRecursive4(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    
    

class PredictionIncludeFromProfile(TypedDict, total=False):
    """Relational arguments for Profile"""
    Report: Union[bool, 'ReportArgsFromProfileRecursive1']
    Profile: Union[bool, 'ProfileArgsFromProfileRecursive1']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromProfileRecursive1']


class PredictionIncludeFromProfileRecursive1(TypedDict, total=False):
    """Relational arguments for Profile"""
    Report: Union[bool, 'ReportArgsFromProfileRecursive2']
    Profile: Union[bool, 'ProfileArgsFromProfileRecursive2']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromProfileRecursive2']


class PredictionIncludeFromProfileRecursive2(TypedDict, total=False):
    """Relational arguments for Profile"""
    Report: Union[bool, 'ReportArgsFromProfileRecursive3']
    Profile: Union[bool, 'ProfileArgsFromProfileRecursive3']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromProfileRecursive3']


class PredictionIncludeFromProfileRecursive3(TypedDict, total=False):
    """Relational arguments for Profile"""
    Report: Union[bool, 'ReportArgsFromProfileRecursive4']
    Profile: Union[bool, 'ProfileArgsFromProfileRecursive4']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromProfileRecursive4']


class PredictionIncludeFromProfileRecursive4(TypedDict, total=False):
    """Relational arguments for Profile"""

    

class PredictionArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'PredictionIncludeFromPredictionRecursive1'


class PredictionArgsFromProfileRecursive1(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'PredictionIncludeFromPredictionRecursive2'


class PredictionArgsFromProfileRecursive2(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'PredictionIncludeFromPredictionRecursive3'


class PredictionArgsFromProfileRecursive3(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'PredictionIncludeFromPredictionRecursive4'


class PredictionArgsFromProfileRecursive4(TypedDict, total=False):
    """Arguments for Profile"""
    
    

class FindManyPredictionArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive1'


class FindManyPredictionArgsFromProfileRecursive1(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive2'


class FindManyPredictionArgsFromProfileRecursive2(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive3'


class FindManyPredictionArgsFromProfileRecursive3(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive4'


class FindManyPredictionArgsFromProfileRecursive4(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    
    

class TriageNoteIncludeFromProfile(TypedDict, total=False):
    """Relational arguments for Profile"""
    Prediction: Union[bool, 'PredictionArgsFromProfileRecursive1']
    Profile: Union[bool, 'ProfileArgsFromProfileRecursive1']


class TriageNoteIncludeFromProfileRecursive1(TypedDict, total=False):
    """Relational arguments for Profile"""
    Prediction: Union[bool, 'PredictionArgsFromProfileRecursive2']
    Profile: Union[bool, 'ProfileArgsFromProfileRecursive2']


class TriageNoteIncludeFromProfileRecursive2(TypedDict, total=False):
    """Relational arguments for Profile"""
    Prediction: Union[bool, 'PredictionArgsFromProfileRecursive3']
    Profile: Union[bool, 'ProfileArgsFromProfileRecursive3']


class TriageNoteIncludeFromProfileRecursive3(TypedDict, total=False):
    """Relational arguments for Profile"""
    Prediction: Union[bool, 'PredictionArgsFromProfileRecursive4']
    Profile: Union[bool, 'ProfileArgsFromProfileRecursive4']


class TriageNoteIncludeFromProfileRecursive4(TypedDict, total=False):
    """Relational arguments for Profile"""

    

class TriageNoteArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive1'


class TriageNoteArgsFromProfileRecursive1(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive2'


class TriageNoteArgsFromProfileRecursive2(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive3'


class TriageNoteArgsFromProfileRecursive3(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive4'


class TriageNoteArgsFromProfileRecursive4(TypedDict, total=False):
    """Arguments for Profile"""
    
    

class FindManyTriageNoteArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive1'


class FindManyTriageNoteArgsFromProfileRecursive1(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive2'


class FindManyTriageNoteArgsFromProfileRecursive2(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive3'


class FindManyTriageNoteArgsFromProfileRecursive3(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive4'


class FindManyTriageNoteArgsFromProfileRecursive4(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    


FindManyProfileArgs = FindManyProfileArgsFromProfile
FindFirstProfileArgs = FindManyProfileArgsFromProfile


    

class ProfileWhereInput(TypedDict, total=False):
    """Profile arguments for searching"""
    userId: Union[_str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Reports: 'ReportListRelationFilter'
    Predictions: 'PredictionListRelationFilter'
    TriageNotes: 'TriageNoteListRelationFilter'

    # should be noted that AND and NOT should be Union['ProfileWhereInputRecursive1', List['ProfileWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ProfileWhereInputRecursive1']
    OR: List['ProfileWhereInputRecursive1']
    NOT: List['ProfileWhereInputRecursive1']


class ProfileWhereInputRecursive1(TypedDict, total=False):
    """Profile arguments for searching"""
    userId: Union[_str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Reports: 'ReportListRelationFilter'
    Predictions: 'PredictionListRelationFilter'
    TriageNotes: 'TriageNoteListRelationFilter'

    # should be noted that AND and NOT should be Union['ProfileWhereInputRecursive2', List['ProfileWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ProfileWhereInputRecursive2']
    OR: List['ProfileWhereInputRecursive2']
    NOT: List['ProfileWhereInputRecursive2']


class ProfileWhereInputRecursive2(TypedDict, total=False):
    """Profile arguments for searching"""
    userId: Union[_str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Reports: 'ReportListRelationFilter'
    Predictions: 'PredictionListRelationFilter'
    TriageNotes: 'TriageNoteListRelationFilter'

    # should be noted that AND and NOT should be Union['ProfileWhereInputRecursive3', List['ProfileWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['ProfileWhereInputRecursive3']
    OR: List['ProfileWhereInputRecursive3']
    NOT: List['ProfileWhereInputRecursive3']


class ProfileWhereInputRecursive3(TypedDict, total=False):
    """Profile arguments for searching"""
    userId: Union[_str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Reports: 'ReportListRelationFilter'
    Predictions: 'PredictionListRelationFilter'
    TriageNotes: 'TriageNoteListRelationFilter'

    # should be noted that AND and NOT should be Union['ProfileWhereInputRecursive4', List['ProfileWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['ProfileWhereInputRecursive4']
    OR: List['ProfileWhereInputRecursive4']
    NOT: List['ProfileWhereInputRecursive4']


class ProfileWhereInputRecursive4(TypedDict, total=False):
    """Profile arguments for searching"""
    userId: Union[_str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Reports: 'ReportListRelationFilter'
    Predictions: 'PredictionListRelationFilter'
    TriageNotes: 'TriageNoteListRelationFilter'



# aggregate Profile types


    

class ProfileScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Profile arguments for searching"""
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProfileScalarWhereWithAggregatesInputRecursive1']
    OR: List['ProfileScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ProfileScalarWhereWithAggregatesInputRecursive1']


class ProfileScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Profile arguments for searching"""
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProfileScalarWhereWithAggregatesInputRecursive2']
    OR: List['ProfileScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ProfileScalarWhereWithAggregatesInputRecursive2']


class ProfileScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Profile arguments for searching"""
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProfileScalarWhereWithAggregatesInputRecursive3']
    OR: List['ProfileScalarWhereWithAggregatesInputRecursive3']
    NOT: List['ProfileScalarWhereWithAggregatesInputRecursive3']


class ProfileScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Profile arguments for searching"""
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProfileScalarWhereWithAggregatesInputRecursive4']
    OR: List['ProfileScalarWhereWithAggregatesInputRecursive4']
    NOT: List['ProfileScalarWhereWithAggregatesInputRecursive4']


class ProfileScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Profile arguments for searching"""
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class ProfileGroupByOutput(TypedDict, total=False):
    userId: _str
    email: _str
    createdAt: datetime.datetime
    _sum: 'ProfileSumAggregateOutput'
    _avg: 'ProfileAvgAggregateOutput'
    _min: 'ProfileMinAggregateOutput'
    _max: 'ProfileMaxAggregateOutput'
    _count: 'ProfileCountAggregateOutput'


class ProfileAvgAggregateOutput(TypedDict, total=False):
    """Profile output for aggregating averages"""


class ProfileSumAggregateOutput(TypedDict, total=False):
    """Profile output for aggregating sums"""


class ProfileScalarAggregateOutput(TypedDict, total=False):
    """Profile output including scalar fields"""
    userId: _str
    email: _str
    createdAt: datetime.datetime


ProfileMinAggregateOutput = ProfileScalarAggregateOutput
ProfileMaxAggregateOutput = ProfileScalarAggregateOutput


class ProfileMaxAggregateInput(TypedDict, total=False):
    """Profile input for aggregating by max"""
    userId: bool
    email: bool
    createdAt: bool


class ProfileMinAggregateInput(TypedDict, total=False):
    """Profile input for aggregating by min"""
    userId: bool
    email: bool
    createdAt: bool


class ProfileNumberAggregateInput(TypedDict, total=False):
    """Profile input for aggregating numbers"""


ProfileAvgAggregateInput = ProfileNumberAggregateInput
ProfileSumAggregateInput = ProfileNumberAggregateInput


ProfileCountAggregateInput = TypedDict(
    'ProfileCountAggregateInput',
    {
        'userId': bool,
        'email': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

ProfileCountAggregateOutput = TypedDict(
    'ProfileCountAggregateOutput',
    {
        'userId': int,
        'email': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


ProfileKeys = Literal[
    'userId',
    'email',
    'createdAt',
    'Reports',
    'Predictions',
    'TriageNotes',
]
ProfileScalarFieldKeys = Literal[
    'userId',
    'email',
    'createdAt',
]
ProfileScalarFieldKeysT = TypeVar('ProfileScalarFieldKeysT', bound=ProfileScalarFieldKeys)

ProfileRelationalFieldKeys = Literal[
        'Reports',
        'Predictions',
        'TriageNotes',
    ]

# Report types

class ReportOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Report create method"""
    id: _str
    userId: _str
    rawFilename: Optional[_str]
    rawOCR: Optional['fields.Json']
    extractedMeta: Optional['fields.Json']
    createdAt: datetime.datetime
    Predictions: 'PredictionCreateManyNestedWithoutRelationsInput'
    Profile: 'ProfileCreateNestedWithoutRelationsInput'


class ReportCreateInput(ReportOptionalCreateInput):
    """Required arguments to the Report create method"""
    task: _str
    extracted: 'fields.Json'
    missingFields: 'fields.Json'
    warnings: 'fields.Json'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ReportOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Report create method, without relations"""
    id: _str
    userId: _str
    rawFilename: Optional[_str]
    rawOCR: Optional['fields.Json']
    extractedMeta: Optional['fields.Json']
    createdAt: datetime.datetime


class ReportCreateWithoutRelationsInput(ReportOptionalCreateWithoutRelationsInput):
    """Required arguments to the Report create method, without relations"""
    task: _str
    extracted: 'fields.Json'
    missingFields: 'fields.Json'
    warnings: 'fields.Json'


class ReportCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ReportCreateWithoutRelationsInput'
    connect: 'ReportWhereUniqueInput'


class ReportCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ReportCreateWithoutRelationsInput', List['ReportCreateWithoutRelationsInput']]
    connect: Union['ReportWhereUniqueInput', List['ReportWhereUniqueInput']]


_ReportWhereUnique_id_Input = TypedDict(
    '_ReportWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ReportWhereUniqueInput = _ReportWhereUnique_id_Input


class ReportUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    task: _str
    rawFilename: Optional[_str]
    extracted: 'fields.Json'
    missingFields: 'fields.Json'
    warnings: 'fields.Json'
    rawOCR: Optional['fields.Json']
    extractedMeta: Optional['fields.Json']
    createdAt: datetime.datetime
    Predictions: 'PredictionUpdateManyWithoutRelationsInput'
    Profile: 'ProfileUpdateOneWithoutRelationsInput'


class ReportUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    task: _str
    rawFilename: Optional[_str]
    extracted: 'fields.Json'
    missingFields: 'fields.Json'
    warnings: 'fields.Json'
    rawOCR: Optional['fields.Json']
    extractedMeta: Optional['fields.Json']
    createdAt: datetime.datetime


class ReportUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ReportCreateWithoutRelationsInput']
    connect: List['ReportWhereUniqueInput']
    set: List['ReportWhereUniqueInput']
    disconnect: List['ReportWhereUniqueInput']
    delete: List['ReportWhereUniqueInput']

    # TODO
    # update: List['ReportUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ReportUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ReportScalarWhereInput']
    # upsert: List['ReportUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['ReportCreateOrConnectWithoutRelationsInput']


class ReportUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ReportCreateWithoutRelationsInput'
    connect: 'ReportWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ReportUpdateInput'
    # upsert: 'ReportUpsertWithoutRelationsInput'
    # connectOrCreate: 'ReportCreateOrConnectWithoutRelationsInput'


class ReportUpsertInput(TypedDict):
    create: 'ReportCreateInput'
    update: 'ReportUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Report_id_OrderByInput = TypedDict(
    '_Report_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Report_userId_OrderByInput = TypedDict(
    '_Report_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Report_task_OrderByInput = TypedDict(
    '_Report_task_OrderByInput',
    {
        'task': 'SortOrder',
    },
    total=True
)

_Report_rawFilename_OrderByInput = TypedDict(
    '_Report_rawFilename_OrderByInput',
    {
        'rawFilename': 'SortOrder',
    },
    total=True
)

_Report_extracted_OrderByInput = TypedDict(
    '_Report_extracted_OrderByInput',
    {
        'extracted': 'SortOrder',
    },
    total=True
)

_Report_missingFields_OrderByInput = TypedDict(
    '_Report_missingFields_OrderByInput',
    {
        'missingFields': 'SortOrder',
    },
    total=True
)

_Report_warnings_OrderByInput = TypedDict(
    '_Report_warnings_OrderByInput',
    {
        'warnings': 'SortOrder',
    },
    total=True
)

_Report_rawOCR_OrderByInput = TypedDict(
    '_Report_rawOCR_OrderByInput',
    {
        'rawOCR': 'SortOrder',
    },
    total=True
)

_Report_extractedMeta_OrderByInput = TypedDict(
    '_Report_extractedMeta_OrderByInput',
    {
        'extractedMeta': 'SortOrder',
    },
    total=True
)

_Report_createdAt_OrderByInput = TypedDict(
    '_Report_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

ReportOrderByInput = Union[
    '_Report_id_OrderByInput',
    '_Report_userId_OrderByInput',
    '_Report_task_OrderByInput',
    '_Report_rawFilename_OrderByInput',
    '_Report_extracted_OrderByInput',
    '_Report_missingFields_OrderByInput',
    '_Report_warnings_OrderByInput',
    '_Report_rawOCR_OrderByInput',
    '_Report_extractedMeta_OrderByInput',
    '_Report_createdAt_OrderByInput',
]



# recursive Report types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ReportRelationFilter = TypedDict(
    'ReportRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ReportListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ReportInclude(TypedDict, total=False):
    """Report relational arguments"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromReport']
    Profile: Union[bool, 'ProfileArgsFromReport']


    

class ProfileIncludeFromReport(TypedDict, total=False):
    """Relational arguments for Report"""
    Reports: Union[bool, 'FindManyReportArgsFromReportRecursive1']
    Predictions: Union[bool, 'FindManyPredictionArgsFromReportRecursive1']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromReportRecursive1']


class ProfileIncludeFromReportRecursive1(TypedDict, total=False):
    """Relational arguments for Report"""
    Reports: Union[bool, 'FindManyReportArgsFromReportRecursive2']
    Predictions: Union[bool, 'FindManyPredictionArgsFromReportRecursive2']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromReportRecursive2']


class ProfileIncludeFromReportRecursive2(TypedDict, total=False):
    """Relational arguments for Report"""
    Reports: Union[bool, 'FindManyReportArgsFromReportRecursive3']
    Predictions: Union[bool, 'FindManyPredictionArgsFromReportRecursive3']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromReportRecursive3']


class ProfileIncludeFromReportRecursive3(TypedDict, total=False):
    """Relational arguments for Report"""
    Reports: Union[bool, 'FindManyReportArgsFromReportRecursive4']
    Predictions: Union[bool, 'FindManyPredictionArgsFromReportRecursive4']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromReportRecursive4']


class ProfileIncludeFromReportRecursive4(TypedDict, total=False):
    """Relational arguments for Report"""

    

class ProfileArgsFromReport(TypedDict, total=False):
    """Arguments for Report"""
    include: 'ProfileIncludeFromProfileRecursive1'


class ProfileArgsFromReportRecursive1(TypedDict, total=False):
    """Arguments for Report"""
    include: 'ProfileIncludeFromProfileRecursive2'


class ProfileArgsFromReportRecursive2(TypedDict, total=False):
    """Arguments for Report"""
    include: 'ProfileIncludeFromProfileRecursive3'


class ProfileArgsFromReportRecursive3(TypedDict, total=False):
    """Arguments for Report"""
    include: 'ProfileIncludeFromProfileRecursive4'


class ProfileArgsFromReportRecursive4(TypedDict, total=False):
    """Arguments for Report"""
    
    

class FindManyProfileArgsFromReport(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive1'


class FindManyProfileArgsFromReportRecursive1(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive2'


class FindManyProfileArgsFromReportRecursive2(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive3'


class FindManyProfileArgsFromReportRecursive3(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive4'


class FindManyProfileArgsFromReportRecursive4(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    
    

class ReportIncludeFromReport(TypedDict, total=False):
    """Relational arguments for Report"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromReportRecursive1']
    Profile: Union[bool, 'ProfileArgsFromReportRecursive1']


class ReportIncludeFromReportRecursive1(TypedDict, total=False):
    """Relational arguments for Report"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromReportRecursive2']
    Profile: Union[bool, 'ProfileArgsFromReportRecursive2']


class ReportIncludeFromReportRecursive2(TypedDict, total=False):
    """Relational arguments for Report"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromReportRecursive3']
    Profile: Union[bool, 'ProfileArgsFromReportRecursive3']


class ReportIncludeFromReportRecursive3(TypedDict, total=False):
    """Relational arguments for Report"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromReportRecursive4']
    Profile: Union[bool, 'ProfileArgsFromReportRecursive4']


class ReportIncludeFromReportRecursive4(TypedDict, total=False):
    """Relational arguments for Report"""

    

class ReportArgsFromReport(TypedDict, total=False):
    """Arguments for Report"""
    include: 'ReportIncludeFromReportRecursive1'


class ReportArgsFromReportRecursive1(TypedDict, total=False):
    """Arguments for Report"""
    include: 'ReportIncludeFromReportRecursive2'


class ReportArgsFromReportRecursive2(TypedDict, total=False):
    """Arguments for Report"""
    include: 'ReportIncludeFromReportRecursive3'


class ReportArgsFromReportRecursive3(TypedDict, total=False):
    """Arguments for Report"""
    include: 'ReportIncludeFromReportRecursive4'


class ReportArgsFromReportRecursive4(TypedDict, total=False):
    """Arguments for Report"""
    
    

class FindManyReportArgsFromReport(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive1'


class FindManyReportArgsFromReportRecursive1(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive2'


class FindManyReportArgsFromReportRecursive2(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive3'


class FindManyReportArgsFromReportRecursive3(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive4'


class FindManyReportArgsFromReportRecursive4(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    
    

class PredictionIncludeFromReport(TypedDict, total=False):
    """Relational arguments for Report"""
    Report: Union[bool, 'ReportArgsFromReportRecursive1']
    Profile: Union[bool, 'ProfileArgsFromReportRecursive1']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromReportRecursive1']


class PredictionIncludeFromReportRecursive1(TypedDict, total=False):
    """Relational arguments for Report"""
    Report: Union[bool, 'ReportArgsFromReportRecursive2']
    Profile: Union[bool, 'ProfileArgsFromReportRecursive2']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromReportRecursive2']


class PredictionIncludeFromReportRecursive2(TypedDict, total=False):
    """Relational arguments for Report"""
    Report: Union[bool, 'ReportArgsFromReportRecursive3']
    Profile: Union[bool, 'ProfileArgsFromReportRecursive3']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromReportRecursive3']


class PredictionIncludeFromReportRecursive3(TypedDict, total=False):
    """Relational arguments for Report"""
    Report: Union[bool, 'ReportArgsFromReportRecursive4']
    Profile: Union[bool, 'ProfileArgsFromReportRecursive4']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromReportRecursive4']


class PredictionIncludeFromReportRecursive4(TypedDict, total=False):
    """Relational arguments for Report"""

    

class PredictionArgsFromReport(TypedDict, total=False):
    """Arguments for Report"""
    include: 'PredictionIncludeFromPredictionRecursive1'


class PredictionArgsFromReportRecursive1(TypedDict, total=False):
    """Arguments for Report"""
    include: 'PredictionIncludeFromPredictionRecursive2'


class PredictionArgsFromReportRecursive2(TypedDict, total=False):
    """Arguments for Report"""
    include: 'PredictionIncludeFromPredictionRecursive3'


class PredictionArgsFromReportRecursive3(TypedDict, total=False):
    """Arguments for Report"""
    include: 'PredictionIncludeFromPredictionRecursive4'


class PredictionArgsFromReportRecursive4(TypedDict, total=False):
    """Arguments for Report"""
    
    

class FindManyPredictionArgsFromReport(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive1'


class FindManyPredictionArgsFromReportRecursive1(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive2'


class FindManyPredictionArgsFromReportRecursive2(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive3'


class FindManyPredictionArgsFromReportRecursive3(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive4'


class FindManyPredictionArgsFromReportRecursive4(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    
    

class TriageNoteIncludeFromReport(TypedDict, total=False):
    """Relational arguments for Report"""
    Prediction: Union[bool, 'PredictionArgsFromReportRecursive1']
    Profile: Union[bool, 'ProfileArgsFromReportRecursive1']


class TriageNoteIncludeFromReportRecursive1(TypedDict, total=False):
    """Relational arguments for Report"""
    Prediction: Union[bool, 'PredictionArgsFromReportRecursive2']
    Profile: Union[bool, 'ProfileArgsFromReportRecursive2']


class TriageNoteIncludeFromReportRecursive2(TypedDict, total=False):
    """Relational arguments for Report"""
    Prediction: Union[bool, 'PredictionArgsFromReportRecursive3']
    Profile: Union[bool, 'ProfileArgsFromReportRecursive3']


class TriageNoteIncludeFromReportRecursive3(TypedDict, total=False):
    """Relational arguments for Report"""
    Prediction: Union[bool, 'PredictionArgsFromReportRecursive4']
    Profile: Union[bool, 'ProfileArgsFromReportRecursive4']


class TriageNoteIncludeFromReportRecursive4(TypedDict, total=False):
    """Relational arguments for Report"""

    

class TriageNoteArgsFromReport(TypedDict, total=False):
    """Arguments for Report"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive1'


class TriageNoteArgsFromReportRecursive1(TypedDict, total=False):
    """Arguments for Report"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive2'


class TriageNoteArgsFromReportRecursive2(TypedDict, total=False):
    """Arguments for Report"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive3'


class TriageNoteArgsFromReportRecursive3(TypedDict, total=False):
    """Arguments for Report"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive4'


class TriageNoteArgsFromReportRecursive4(TypedDict, total=False):
    """Arguments for Report"""
    
    

class FindManyTriageNoteArgsFromReport(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive1'


class FindManyTriageNoteArgsFromReportRecursive1(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive2'


class FindManyTriageNoteArgsFromReportRecursive2(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive3'


class FindManyTriageNoteArgsFromReportRecursive3(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive4'


class FindManyTriageNoteArgsFromReportRecursive4(TypedDict, total=False):
    """Arguments for Report"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    


FindManyReportArgs = FindManyReportArgsFromReport
FindFirstReportArgs = FindManyReportArgsFromReport


    

class ReportWhereInput(TypedDict, total=False):
    """Report arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    task: Union[_str, 'types.StringFilter']
    rawFilename: Union[None, _str, 'types.StringFilter']
    extracted: Union['fields.Json', 'types.JsonFilter']
    missingFields: Union['fields.Json', 'types.JsonFilter']
    warnings: Union['fields.Json', 'types.JsonFilter']
    rawOCR: Union[None, 'fields.Json', 'types.JsonFilter']
    extractedMeta: Union[None, 'fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Predictions: 'PredictionListRelationFilter'
    Profile: 'ProfileRelationFilter'

    # should be noted that AND and NOT should be Union['ReportWhereInputRecursive1', List['ReportWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ReportWhereInputRecursive1']
    OR: List['ReportWhereInputRecursive1']
    NOT: List['ReportWhereInputRecursive1']


class ReportWhereInputRecursive1(TypedDict, total=False):
    """Report arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    task: Union[_str, 'types.StringFilter']
    rawFilename: Union[None, _str, 'types.StringFilter']
    extracted: Union['fields.Json', 'types.JsonFilter']
    missingFields: Union['fields.Json', 'types.JsonFilter']
    warnings: Union['fields.Json', 'types.JsonFilter']
    rawOCR: Union[None, 'fields.Json', 'types.JsonFilter']
    extractedMeta: Union[None, 'fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Predictions: 'PredictionListRelationFilter'
    Profile: 'ProfileRelationFilter'

    # should be noted that AND and NOT should be Union['ReportWhereInputRecursive2', List['ReportWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ReportWhereInputRecursive2']
    OR: List['ReportWhereInputRecursive2']
    NOT: List['ReportWhereInputRecursive2']


class ReportWhereInputRecursive2(TypedDict, total=False):
    """Report arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    task: Union[_str, 'types.StringFilter']
    rawFilename: Union[None, _str, 'types.StringFilter']
    extracted: Union['fields.Json', 'types.JsonFilter']
    missingFields: Union['fields.Json', 'types.JsonFilter']
    warnings: Union['fields.Json', 'types.JsonFilter']
    rawOCR: Union[None, 'fields.Json', 'types.JsonFilter']
    extractedMeta: Union[None, 'fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Predictions: 'PredictionListRelationFilter'
    Profile: 'ProfileRelationFilter'

    # should be noted that AND and NOT should be Union['ReportWhereInputRecursive3', List['ReportWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['ReportWhereInputRecursive3']
    OR: List['ReportWhereInputRecursive3']
    NOT: List['ReportWhereInputRecursive3']


class ReportWhereInputRecursive3(TypedDict, total=False):
    """Report arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    task: Union[_str, 'types.StringFilter']
    rawFilename: Union[None, _str, 'types.StringFilter']
    extracted: Union['fields.Json', 'types.JsonFilter']
    missingFields: Union['fields.Json', 'types.JsonFilter']
    warnings: Union['fields.Json', 'types.JsonFilter']
    rawOCR: Union[None, 'fields.Json', 'types.JsonFilter']
    extractedMeta: Union[None, 'fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Predictions: 'PredictionListRelationFilter'
    Profile: 'ProfileRelationFilter'

    # should be noted that AND and NOT should be Union['ReportWhereInputRecursive4', List['ReportWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['ReportWhereInputRecursive4']
    OR: List['ReportWhereInputRecursive4']
    NOT: List['ReportWhereInputRecursive4']


class ReportWhereInputRecursive4(TypedDict, total=False):
    """Report arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    task: Union[_str, 'types.StringFilter']
    rawFilename: Union[None, _str, 'types.StringFilter']
    extracted: Union['fields.Json', 'types.JsonFilter']
    missingFields: Union['fields.Json', 'types.JsonFilter']
    warnings: Union['fields.Json', 'types.JsonFilter']
    rawOCR: Union[None, 'fields.Json', 'types.JsonFilter']
    extractedMeta: Union[None, 'fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Predictions: 'PredictionListRelationFilter'
    Profile: 'ProfileRelationFilter'



# aggregate Report types


    

class ReportScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Report arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    task: Union[_str, 'types.StringWithAggregatesFilter']
    rawFilename: Union[_str, 'types.StringWithAggregatesFilter']
    extracted: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    missingFields: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    warnings: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    rawOCR: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    extractedMeta: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ReportScalarWhereWithAggregatesInputRecursive1']
    OR: List['ReportScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ReportScalarWhereWithAggregatesInputRecursive1']


class ReportScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Report arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    task: Union[_str, 'types.StringWithAggregatesFilter']
    rawFilename: Union[_str, 'types.StringWithAggregatesFilter']
    extracted: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    missingFields: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    warnings: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    rawOCR: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    extractedMeta: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ReportScalarWhereWithAggregatesInputRecursive2']
    OR: List['ReportScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ReportScalarWhereWithAggregatesInputRecursive2']


class ReportScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Report arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    task: Union[_str, 'types.StringWithAggregatesFilter']
    rawFilename: Union[_str, 'types.StringWithAggregatesFilter']
    extracted: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    missingFields: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    warnings: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    rawOCR: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    extractedMeta: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ReportScalarWhereWithAggregatesInputRecursive3']
    OR: List['ReportScalarWhereWithAggregatesInputRecursive3']
    NOT: List['ReportScalarWhereWithAggregatesInputRecursive3']


class ReportScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Report arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    task: Union[_str, 'types.StringWithAggregatesFilter']
    rawFilename: Union[_str, 'types.StringWithAggregatesFilter']
    extracted: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    missingFields: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    warnings: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    rawOCR: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    extractedMeta: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ReportScalarWhereWithAggregatesInputRecursive4']
    OR: List['ReportScalarWhereWithAggregatesInputRecursive4']
    NOT: List['ReportScalarWhereWithAggregatesInputRecursive4']


class ReportScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Report arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    task: Union[_str, 'types.StringWithAggregatesFilter']
    rawFilename: Union[_str, 'types.StringWithAggregatesFilter']
    extracted: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    missingFields: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    warnings: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    rawOCR: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    extractedMeta: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class ReportGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    task: _str
    rawFilename: _str
    extracted: 'fields.Json'
    missingFields: 'fields.Json'
    warnings: 'fields.Json'
    rawOCR: 'fields.Json'
    extractedMeta: 'fields.Json'
    createdAt: datetime.datetime
    _sum: 'ReportSumAggregateOutput'
    _avg: 'ReportAvgAggregateOutput'
    _min: 'ReportMinAggregateOutput'
    _max: 'ReportMaxAggregateOutput'
    _count: 'ReportCountAggregateOutput'


class ReportAvgAggregateOutput(TypedDict, total=False):
    """Report output for aggregating averages"""


class ReportSumAggregateOutput(TypedDict, total=False):
    """Report output for aggregating sums"""


class ReportScalarAggregateOutput(TypedDict, total=False):
    """Report output including scalar fields"""
    id: _str
    userId: _str
    task: _str
    rawFilename: _str
    extracted: 'fields.Json'
    missingFields: 'fields.Json'
    warnings: 'fields.Json'
    rawOCR: 'fields.Json'
    extractedMeta: 'fields.Json'
    createdAt: datetime.datetime


ReportMinAggregateOutput = ReportScalarAggregateOutput
ReportMaxAggregateOutput = ReportScalarAggregateOutput


class ReportMaxAggregateInput(TypedDict, total=False):
    """Report input for aggregating by max"""
    id: bool
    userId: bool
    task: bool
    rawFilename: bool
    extracted: bool
    missingFields: bool
    warnings: bool
    rawOCR: bool
    extractedMeta: bool
    createdAt: bool


class ReportMinAggregateInput(TypedDict, total=False):
    """Report input for aggregating by min"""
    id: bool
    userId: bool
    task: bool
    rawFilename: bool
    extracted: bool
    missingFields: bool
    warnings: bool
    rawOCR: bool
    extractedMeta: bool
    createdAt: bool


class ReportNumberAggregateInput(TypedDict, total=False):
    """Report input for aggregating numbers"""


ReportAvgAggregateInput = ReportNumberAggregateInput
ReportSumAggregateInput = ReportNumberAggregateInput


ReportCountAggregateInput = TypedDict(
    'ReportCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'task': bool,
        'rawFilename': bool,
        'extracted': bool,
        'missingFields': bool,
        'warnings': bool,
        'rawOCR': bool,
        'extractedMeta': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

ReportCountAggregateOutput = TypedDict(
    'ReportCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'task': int,
        'rawFilename': int,
        'extracted': int,
        'missingFields': int,
        'warnings': int,
        'rawOCR': int,
        'extractedMeta': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


ReportKeys = Literal[
    'id',
    'userId',
    'task',
    'rawFilename',
    'extracted',
    'missingFields',
    'warnings',
    'rawOCR',
    'extractedMeta',
    'createdAt',
    'Predictions',
    'Profile',
]
ReportScalarFieldKeys = Literal[
    'id',
    'userId',
    'task',
    'rawFilename',
    'extracted',
    'missingFields',
    'warnings',
    'rawOCR',
    'extractedMeta',
    'createdAt',
]
ReportScalarFieldKeysT = TypeVar('ReportScalarFieldKeysT', bound=ReportScalarFieldKeys)

ReportRelationalFieldKeys = Literal[
        'Predictions',
        'Profile',
    ]

# Prediction types

class PredictionOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Prediction create method"""
    id: _str
    userId: _str
    reportId: Optional[_str]
    createdAt: datetime.datetime
    Report: 'ReportCreateNestedWithoutRelationsInput'
    Profile: 'ProfileCreateNestedWithoutRelationsInput'
    TriageNotes: 'TriageNoteCreateManyNestedWithoutRelationsInput'


class PredictionCreateInput(PredictionOptionalCreateInput):
    """Required arguments to the Prediction create method"""
    task: _str
    features: 'fields.Json'
    label: _int
    probability: _float
    healthScore: _float
    topContributors: 'fields.Json'
    warnings: 'fields.Json'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PredictionOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Prediction create method, without relations"""
    id: _str
    userId: _str
    reportId: Optional[_str]
    createdAt: datetime.datetime


class PredictionCreateWithoutRelationsInput(PredictionOptionalCreateWithoutRelationsInput):
    """Required arguments to the Prediction create method, without relations"""
    task: _str
    features: 'fields.Json'
    label: _int
    probability: _float
    healthScore: _float
    topContributors: 'fields.Json'
    warnings: 'fields.Json'


class PredictionCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PredictionCreateWithoutRelationsInput'
    connect: 'PredictionWhereUniqueInput'


class PredictionCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PredictionCreateWithoutRelationsInput', List['PredictionCreateWithoutRelationsInput']]
    connect: Union['PredictionWhereUniqueInput', List['PredictionWhereUniqueInput']]


_PredictionWhereUnique_id_Input = TypedDict(
    '_PredictionWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

PredictionWhereUniqueInput = _PredictionWhereUnique_id_Input


class PredictionUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    task: _str
    features: 'fields.Json'
    label: Union[AtomicIntInput, _int]
    probability: Union[AtomicFloatInput, _float]
    healthScore: Union[AtomicFloatInput, _float]
    topContributors: 'fields.Json'
    warnings: 'fields.Json'
    createdAt: datetime.datetime
    Report: 'ReportUpdateOneWithoutRelationsInput'
    Profile: 'ProfileUpdateOneWithoutRelationsInput'
    TriageNotes: 'TriageNoteUpdateManyWithoutRelationsInput'


class PredictionUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    task: _str
    features: 'fields.Json'
    label: Union[AtomicIntInput, _int]
    probability: Union[AtomicFloatInput, _float]
    healthScore: Union[AtomicFloatInput, _float]
    topContributors: 'fields.Json'
    warnings: 'fields.Json'
    createdAt: datetime.datetime


class PredictionUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PredictionCreateWithoutRelationsInput']
    connect: List['PredictionWhereUniqueInput']
    set: List['PredictionWhereUniqueInput']
    disconnect: List['PredictionWhereUniqueInput']
    delete: List['PredictionWhereUniqueInput']

    # TODO
    # update: List['PredictionUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PredictionUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PredictionScalarWhereInput']
    # upsert: List['PredictionUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['PredictionCreateOrConnectWithoutRelationsInput']


class PredictionUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PredictionCreateWithoutRelationsInput'
    connect: 'PredictionWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PredictionUpdateInput'
    # upsert: 'PredictionUpsertWithoutRelationsInput'
    # connectOrCreate: 'PredictionCreateOrConnectWithoutRelationsInput'


class PredictionUpsertInput(TypedDict):
    create: 'PredictionCreateInput'
    update: 'PredictionUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Prediction_id_OrderByInput = TypedDict(
    '_Prediction_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Prediction_userId_OrderByInput = TypedDict(
    '_Prediction_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Prediction_reportId_OrderByInput = TypedDict(
    '_Prediction_reportId_OrderByInput',
    {
        'reportId': 'SortOrder',
    },
    total=True
)

_Prediction_task_OrderByInput = TypedDict(
    '_Prediction_task_OrderByInput',
    {
        'task': 'SortOrder',
    },
    total=True
)

_Prediction_features_OrderByInput = TypedDict(
    '_Prediction_features_OrderByInput',
    {
        'features': 'SortOrder',
    },
    total=True
)

_Prediction_label_OrderByInput = TypedDict(
    '_Prediction_label_OrderByInput',
    {
        'label': 'SortOrder',
    },
    total=True
)

_Prediction_probability_OrderByInput = TypedDict(
    '_Prediction_probability_OrderByInput',
    {
        'probability': 'SortOrder',
    },
    total=True
)

_Prediction_healthScore_OrderByInput = TypedDict(
    '_Prediction_healthScore_OrderByInput',
    {
        'healthScore': 'SortOrder',
    },
    total=True
)

_Prediction_topContributors_OrderByInput = TypedDict(
    '_Prediction_topContributors_OrderByInput',
    {
        'topContributors': 'SortOrder',
    },
    total=True
)

_Prediction_warnings_OrderByInput = TypedDict(
    '_Prediction_warnings_OrderByInput',
    {
        'warnings': 'SortOrder',
    },
    total=True
)

_Prediction_createdAt_OrderByInput = TypedDict(
    '_Prediction_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

PredictionOrderByInput = Union[
    '_Prediction_id_OrderByInput',
    '_Prediction_userId_OrderByInput',
    '_Prediction_reportId_OrderByInput',
    '_Prediction_task_OrderByInput',
    '_Prediction_features_OrderByInput',
    '_Prediction_label_OrderByInput',
    '_Prediction_probability_OrderByInput',
    '_Prediction_healthScore_OrderByInput',
    '_Prediction_topContributors_OrderByInput',
    '_Prediction_warnings_OrderByInput',
    '_Prediction_createdAt_OrderByInput',
]



# recursive Prediction types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

PredictionRelationFilter = TypedDict(
    'PredictionRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class PredictionListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class PredictionInclude(TypedDict, total=False):
    """Prediction relational arguments"""
    Report: Union[bool, 'ReportArgsFromPrediction']
    Profile: Union[bool, 'ProfileArgsFromPrediction']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromPrediction']


    

class ProfileIncludeFromPrediction(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Reports: Union[bool, 'FindManyReportArgsFromPredictionRecursive1']
    Predictions: Union[bool, 'FindManyPredictionArgsFromPredictionRecursive1']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromPredictionRecursive1']


class ProfileIncludeFromPredictionRecursive1(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Reports: Union[bool, 'FindManyReportArgsFromPredictionRecursive2']
    Predictions: Union[bool, 'FindManyPredictionArgsFromPredictionRecursive2']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromPredictionRecursive2']


class ProfileIncludeFromPredictionRecursive2(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Reports: Union[bool, 'FindManyReportArgsFromPredictionRecursive3']
    Predictions: Union[bool, 'FindManyPredictionArgsFromPredictionRecursive3']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromPredictionRecursive3']


class ProfileIncludeFromPredictionRecursive3(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Reports: Union[bool, 'FindManyReportArgsFromPredictionRecursive4']
    Predictions: Union[bool, 'FindManyPredictionArgsFromPredictionRecursive4']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromPredictionRecursive4']


class ProfileIncludeFromPredictionRecursive4(TypedDict, total=False):
    """Relational arguments for Prediction"""

    

class ProfileArgsFromPrediction(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'ProfileIncludeFromProfileRecursive1'


class ProfileArgsFromPredictionRecursive1(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'ProfileIncludeFromProfileRecursive2'


class ProfileArgsFromPredictionRecursive2(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'ProfileIncludeFromProfileRecursive3'


class ProfileArgsFromPredictionRecursive3(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'ProfileIncludeFromProfileRecursive4'


class ProfileArgsFromPredictionRecursive4(TypedDict, total=False):
    """Arguments for Prediction"""
    
    

class FindManyProfileArgsFromPrediction(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive1'


class FindManyProfileArgsFromPredictionRecursive1(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive2'


class FindManyProfileArgsFromPredictionRecursive2(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive3'


class FindManyProfileArgsFromPredictionRecursive3(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive4'


class FindManyProfileArgsFromPredictionRecursive4(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    
    

class ReportIncludeFromPrediction(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromPredictionRecursive1']
    Profile: Union[bool, 'ProfileArgsFromPredictionRecursive1']


class ReportIncludeFromPredictionRecursive1(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromPredictionRecursive2']
    Profile: Union[bool, 'ProfileArgsFromPredictionRecursive2']


class ReportIncludeFromPredictionRecursive2(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromPredictionRecursive3']
    Profile: Union[bool, 'ProfileArgsFromPredictionRecursive3']


class ReportIncludeFromPredictionRecursive3(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromPredictionRecursive4']
    Profile: Union[bool, 'ProfileArgsFromPredictionRecursive4']


class ReportIncludeFromPredictionRecursive4(TypedDict, total=False):
    """Relational arguments for Prediction"""

    

class ReportArgsFromPrediction(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'ReportIncludeFromReportRecursive1'


class ReportArgsFromPredictionRecursive1(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'ReportIncludeFromReportRecursive2'


class ReportArgsFromPredictionRecursive2(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'ReportIncludeFromReportRecursive3'


class ReportArgsFromPredictionRecursive3(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'ReportIncludeFromReportRecursive4'


class ReportArgsFromPredictionRecursive4(TypedDict, total=False):
    """Arguments for Prediction"""
    
    

class FindManyReportArgsFromPrediction(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive1'


class FindManyReportArgsFromPredictionRecursive1(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive2'


class FindManyReportArgsFromPredictionRecursive2(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive3'


class FindManyReportArgsFromPredictionRecursive3(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive4'


class FindManyReportArgsFromPredictionRecursive4(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    
    

class PredictionIncludeFromPrediction(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Report: Union[bool, 'ReportArgsFromPredictionRecursive1']
    Profile: Union[bool, 'ProfileArgsFromPredictionRecursive1']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromPredictionRecursive1']


class PredictionIncludeFromPredictionRecursive1(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Report: Union[bool, 'ReportArgsFromPredictionRecursive2']
    Profile: Union[bool, 'ProfileArgsFromPredictionRecursive2']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromPredictionRecursive2']


class PredictionIncludeFromPredictionRecursive2(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Report: Union[bool, 'ReportArgsFromPredictionRecursive3']
    Profile: Union[bool, 'ProfileArgsFromPredictionRecursive3']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromPredictionRecursive3']


class PredictionIncludeFromPredictionRecursive3(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Report: Union[bool, 'ReportArgsFromPredictionRecursive4']
    Profile: Union[bool, 'ProfileArgsFromPredictionRecursive4']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromPredictionRecursive4']


class PredictionIncludeFromPredictionRecursive4(TypedDict, total=False):
    """Relational arguments for Prediction"""

    

class PredictionArgsFromPrediction(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'PredictionIncludeFromPredictionRecursive1'


class PredictionArgsFromPredictionRecursive1(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'PredictionIncludeFromPredictionRecursive2'


class PredictionArgsFromPredictionRecursive2(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'PredictionIncludeFromPredictionRecursive3'


class PredictionArgsFromPredictionRecursive3(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'PredictionIncludeFromPredictionRecursive4'


class PredictionArgsFromPredictionRecursive4(TypedDict, total=False):
    """Arguments for Prediction"""
    
    

class FindManyPredictionArgsFromPrediction(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive1'


class FindManyPredictionArgsFromPredictionRecursive1(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive2'


class FindManyPredictionArgsFromPredictionRecursive2(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive3'


class FindManyPredictionArgsFromPredictionRecursive3(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive4'


class FindManyPredictionArgsFromPredictionRecursive4(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    
    

class TriageNoteIncludeFromPrediction(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Prediction: Union[bool, 'PredictionArgsFromPredictionRecursive1']
    Profile: Union[bool, 'ProfileArgsFromPredictionRecursive1']


class TriageNoteIncludeFromPredictionRecursive1(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Prediction: Union[bool, 'PredictionArgsFromPredictionRecursive2']
    Profile: Union[bool, 'ProfileArgsFromPredictionRecursive2']


class TriageNoteIncludeFromPredictionRecursive2(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Prediction: Union[bool, 'PredictionArgsFromPredictionRecursive3']
    Profile: Union[bool, 'ProfileArgsFromPredictionRecursive3']


class TriageNoteIncludeFromPredictionRecursive3(TypedDict, total=False):
    """Relational arguments for Prediction"""
    Prediction: Union[bool, 'PredictionArgsFromPredictionRecursive4']
    Profile: Union[bool, 'ProfileArgsFromPredictionRecursive4']


class TriageNoteIncludeFromPredictionRecursive4(TypedDict, total=False):
    """Relational arguments for Prediction"""

    

class TriageNoteArgsFromPrediction(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive1'


class TriageNoteArgsFromPredictionRecursive1(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive2'


class TriageNoteArgsFromPredictionRecursive2(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive3'


class TriageNoteArgsFromPredictionRecursive3(TypedDict, total=False):
    """Arguments for Prediction"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive4'


class TriageNoteArgsFromPredictionRecursive4(TypedDict, total=False):
    """Arguments for Prediction"""
    
    

class FindManyTriageNoteArgsFromPrediction(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive1'


class FindManyTriageNoteArgsFromPredictionRecursive1(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive2'


class FindManyTriageNoteArgsFromPredictionRecursive2(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive3'


class FindManyTriageNoteArgsFromPredictionRecursive3(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive4'


class FindManyTriageNoteArgsFromPredictionRecursive4(TypedDict, total=False):
    """Arguments for Prediction"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    


FindManyPredictionArgs = FindManyPredictionArgsFromPrediction
FindFirstPredictionArgs = FindManyPredictionArgsFromPrediction


    

class PredictionWhereInput(TypedDict, total=False):
    """Prediction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    reportId: Union[None, _str, 'types.StringFilter']
    task: Union[_str, 'types.StringFilter']
    features: Union['fields.Json', 'types.JsonFilter']
    label: Union[_int, 'types.IntFilter']
    probability: Union[_float, 'types.FloatFilter']
    healthScore: Union[_float, 'types.FloatFilter']
    topContributors: Union['fields.Json', 'types.JsonFilter']
    warnings: Union['fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Report: 'ReportRelationFilter'
    Profile: 'ProfileRelationFilter'
    TriageNotes: 'TriageNoteListRelationFilter'

    # should be noted that AND and NOT should be Union['PredictionWhereInputRecursive1', List['PredictionWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['PredictionWhereInputRecursive1']
    OR: List['PredictionWhereInputRecursive1']
    NOT: List['PredictionWhereInputRecursive1']


class PredictionWhereInputRecursive1(TypedDict, total=False):
    """Prediction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    reportId: Union[None, _str, 'types.StringFilter']
    task: Union[_str, 'types.StringFilter']
    features: Union['fields.Json', 'types.JsonFilter']
    label: Union[_int, 'types.IntFilter']
    probability: Union[_float, 'types.FloatFilter']
    healthScore: Union[_float, 'types.FloatFilter']
    topContributors: Union['fields.Json', 'types.JsonFilter']
    warnings: Union['fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Report: 'ReportRelationFilter'
    Profile: 'ProfileRelationFilter'
    TriageNotes: 'TriageNoteListRelationFilter'

    # should be noted that AND and NOT should be Union['PredictionWhereInputRecursive2', List['PredictionWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['PredictionWhereInputRecursive2']
    OR: List['PredictionWhereInputRecursive2']
    NOT: List['PredictionWhereInputRecursive2']


class PredictionWhereInputRecursive2(TypedDict, total=False):
    """Prediction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    reportId: Union[None, _str, 'types.StringFilter']
    task: Union[_str, 'types.StringFilter']
    features: Union['fields.Json', 'types.JsonFilter']
    label: Union[_int, 'types.IntFilter']
    probability: Union[_float, 'types.FloatFilter']
    healthScore: Union[_float, 'types.FloatFilter']
    topContributors: Union['fields.Json', 'types.JsonFilter']
    warnings: Union['fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Report: 'ReportRelationFilter'
    Profile: 'ProfileRelationFilter'
    TriageNotes: 'TriageNoteListRelationFilter'

    # should be noted that AND and NOT should be Union['PredictionWhereInputRecursive3', List['PredictionWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['PredictionWhereInputRecursive3']
    OR: List['PredictionWhereInputRecursive3']
    NOT: List['PredictionWhereInputRecursive3']


class PredictionWhereInputRecursive3(TypedDict, total=False):
    """Prediction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    reportId: Union[None, _str, 'types.StringFilter']
    task: Union[_str, 'types.StringFilter']
    features: Union['fields.Json', 'types.JsonFilter']
    label: Union[_int, 'types.IntFilter']
    probability: Union[_float, 'types.FloatFilter']
    healthScore: Union[_float, 'types.FloatFilter']
    topContributors: Union['fields.Json', 'types.JsonFilter']
    warnings: Union['fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Report: 'ReportRelationFilter'
    Profile: 'ProfileRelationFilter'
    TriageNotes: 'TriageNoteListRelationFilter'

    # should be noted that AND and NOT should be Union['PredictionWhereInputRecursive4', List['PredictionWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['PredictionWhereInputRecursive4']
    OR: List['PredictionWhereInputRecursive4']
    NOT: List['PredictionWhereInputRecursive4']


class PredictionWhereInputRecursive4(TypedDict, total=False):
    """Prediction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    reportId: Union[None, _str, 'types.StringFilter']
    task: Union[_str, 'types.StringFilter']
    features: Union['fields.Json', 'types.JsonFilter']
    label: Union[_int, 'types.IntFilter']
    probability: Union[_float, 'types.FloatFilter']
    healthScore: Union[_float, 'types.FloatFilter']
    topContributors: Union['fields.Json', 'types.JsonFilter']
    warnings: Union['fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Report: 'ReportRelationFilter'
    Profile: 'ProfileRelationFilter'
    TriageNotes: 'TriageNoteListRelationFilter'



# aggregate Prediction types


    

class PredictionScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Prediction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    reportId: Union[_str, 'types.StringWithAggregatesFilter']
    task: Union[_str, 'types.StringWithAggregatesFilter']
    features: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    label: Union[_int, 'types.IntWithAggregatesFilter']
    probability: Union[_float, 'types.FloatWithAggregatesFilter']
    healthScore: Union[_float, 'types.FloatWithAggregatesFilter']
    topContributors: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    warnings: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PredictionScalarWhereWithAggregatesInputRecursive1']
    OR: List['PredictionScalarWhereWithAggregatesInputRecursive1']
    NOT: List['PredictionScalarWhereWithAggregatesInputRecursive1']


class PredictionScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Prediction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    reportId: Union[_str, 'types.StringWithAggregatesFilter']
    task: Union[_str, 'types.StringWithAggregatesFilter']
    features: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    label: Union[_int, 'types.IntWithAggregatesFilter']
    probability: Union[_float, 'types.FloatWithAggregatesFilter']
    healthScore: Union[_float, 'types.FloatWithAggregatesFilter']
    topContributors: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    warnings: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PredictionScalarWhereWithAggregatesInputRecursive2']
    OR: List['PredictionScalarWhereWithAggregatesInputRecursive2']
    NOT: List['PredictionScalarWhereWithAggregatesInputRecursive2']


class PredictionScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Prediction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    reportId: Union[_str, 'types.StringWithAggregatesFilter']
    task: Union[_str, 'types.StringWithAggregatesFilter']
    features: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    label: Union[_int, 'types.IntWithAggregatesFilter']
    probability: Union[_float, 'types.FloatWithAggregatesFilter']
    healthScore: Union[_float, 'types.FloatWithAggregatesFilter']
    topContributors: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    warnings: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PredictionScalarWhereWithAggregatesInputRecursive3']
    OR: List['PredictionScalarWhereWithAggregatesInputRecursive3']
    NOT: List['PredictionScalarWhereWithAggregatesInputRecursive3']


class PredictionScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Prediction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    reportId: Union[_str, 'types.StringWithAggregatesFilter']
    task: Union[_str, 'types.StringWithAggregatesFilter']
    features: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    label: Union[_int, 'types.IntWithAggregatesFilter']
    probability: Union[_float, 'types.FloatWithAggregatesFilter']
    healthScore: Union[_float, 'types.FloatWithAggregatesFilter']
    topContributors: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    warnings: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PredictionScalarWhereWithAggregatesInputRecursive4']
    OR: List['PredictionScalarWhereWithAggregatesInputRecursive4']
    NOT: List['PredictionScalarWhereWithAggregatesInputRecursive4']


class PredictionScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Prediction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    reportId: Union[_str, 'types.StringWithAggregatesFilter']
    task: Union[_str, 'types.StringWithAggregatesFilter']
    features: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    label: Union[_int, 'types.IntWithAggregatesFilter']
    probability: Union[_float, 'types.FloatWithAggregatesFilter']
    healthScore: Union[_float, 'types.FloatWithAggregatesFilter']
    topContributors: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    warnings: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class PredictionGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    reportId: _str
    task: _str
    features: 'fields.Json'
    label: _int
    probability: _float
    healthScore: _float
    topContributors: 'fields.Json'
    warnings: 'fields.Json'
    createdAt: datetime.datetime
    _sum: 'PredictionSumAggregateOutput'
    _avg: 'PredictionAvgAggregateOutput'
    _min: 'PredictionMinAggregateOutput'
    _max: 'PredictionMaxAggregateOutput'
    _count: 'PredictionCountAggregateOutput'


class PredictionAvgAggregateOutput(TypedDict, total=False):
    """Prediction output for aggregating averages"""
    label: float
    probability: float
    healthScore: float


class PredictionSumAggregateOutput(TypedDict, total=False):
    """Prediction output for aggregating sums"""
    label: _int
    probability: _float
    healthScore: _float


class PredictionScalarAggregateOutput(TypedDict, total=False):
    """Prediction output including scalar fields"""
    id: _str
    userId: _str
    reportId: _str
    task: _str
    features: 'fields.Json'
    label: _int
    probability: _float
    healthScore: _float
    topContributors: 'fields.Json'
    warnings: 'fields.Json'
    createdAt: datetime.datetime


PredictionMinAggregateOutput = PredictionScalarAggregateOutput
PredictionMaxAggregateOutput = PredictionScalarAggregateOutput


class PredictionMaxAggregateInput(TypedDict, total=False):
    """Prediction input for aggregating by max"""
    id: bool
    userId: bool
    reportId: bool
    task: bool
    features: bool
    label: bool
    probability: bool
    healthScore: bool
    topContributors: bool
    warnings: bool
    createdAt: bool


class PredictionMinAggregateInput(TypedDict, total=False):
    """Prediction input for aggregating by min"""
    id: bool
    userId: bool
    reportId: bool
    task: bool
    features: bool
    label: bool
    probability: bool
    healthScore: bool
    topContributors: bool
    warnings: bool
    createdAt: bool


class PredictionNumberAggregateInput(TypedDict, total=False):
    """Prediction input for aggregating numbers"""
    label: bool
    probability: bool
    healthScore: bool


PredictionAvgAggregateInput = PredictionNumberAggregateInput
PredictionSumAggregateInput = PredictionNumberAggregateInput


PredictionCountAggregateInput = TypedDict(
    'PredictionCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'reportId': bool,
        'task': bool,
        'features': bool,
        'label': bool,
        'probability': bool,
        'healthScore': bool,
        'topContributors': bool,
        'warnings': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

PredictionCountAggregateOutput = TypedDict(
    'PredictionCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'reportId': int,
        'task': int,
        'features': int,
        'label': int,
        'probability': int,
        'healthScore': int,
        'topContributors': int,
        'warnings': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


PredictionKeys = Literal[
    'id',
    'userId',
    'reportId',
    'task',
    'features',
    'label',
    'probability',
    'healthScore',
    'topContributors',
    'warnings',
    'createdAt',
    'Report',
    'Profile',
    'TriageNotes',
]
PredictionScalarFieldKeys = Literal[
    'id',
    'userId',
    'reportId',
    'task',
    'features',
    'label',
    'probability',
    'healthScore',
    'topContributors',
    'warnings',
    'createdAt',
]
PredictionScalarFieldKeysT = TypeVar('PredictionScalarFieldKeysT', bound=PredictionScalarFieldKeys)

PredictionRelationalFieldKeys = Literal[
        'Report',
        'Profile',
        'TriageNotes',
    ]

# TriageNote types

class TriageNoteOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the TriageNote create method"""
    id: _str
    userId: _str
    predictionId: _str
    complaint: Optional[_str]
    modelName: Optional[_str]
    createdAt: datetime.datetime
    Prediction: 'PredictionCreateNestedWithoutRelationsInput'
    Profile: 'ProfileCreateNestedWithoutRelationsInput'


class TriageNoteCreateInput(TriageNoteOptionalCreateInput):
    """Required arguments to the TriageNote create method"""
    triageSummary: _str
    followups: 'fields.Json'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TriageNoteOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the TriageNote create method, without relations"""
    id: _str
    userId: _str
    predictionId: _str
    complaint: Optional[_str]
    modelName: Optional[_str]
    createdAt: datetime.datetime


class TriageNoteCreateWithoutRelationsInput(TriageNoteOptionalCreateWithoutRelationsInput):
    """Required arguments to the TriageNote create method, without relations"""
    triageSummary: _str
    followups: 'fields.Json'


class TriageNoteCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TriageNoteCreateWithoutRelationsInput'
    connect: 'TriageNoteWhereUniqueInput'


class TriageNoteCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TriageNoteCreateWithoutRelationsInput', List['TriageNoteCreateWithoutRelationsInput']]
    connect: Union['TriageNoteWhereUniqueInput', List['TriageNoteWhereUniqueInput']]


_TriageNoteWhereUnique_id_Input = TypedDict(
    '_TriageNoteWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

TriageNoteWhereUniqueInput = _TriageNoteWhereUnique_id_Input


class TriageNoteUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    complaint: Optional[_str]
    triageSummary: _str
    followups: 'fields.Json'
    modelName: Optional[_str]
    createdAt: datetime.datetime
    Prediction: 'PredictionUpdateOneWithoutRelationsInput'
    Profile: 'ProfileUpdateOneWithoutRelationsInput'


class TriageNoteUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    complaint: Optional[_str]
    triageSummary: _str
    followups: 'fields.Json'
    modelName: Optional[_str]
    createdAt: datetime.datetime


class TriageNoteUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TriageNoteCreateWithoutRelationsInput']
    connect: List['TriageNoteWhereUniqueInput']
    set: List['TriageNoteWhereUniqueInput']
    disconnect: List['TriageNoteWhereUniqueInput']
    delete: List['TriageNoteWhereUniqueInput']

    # TODO
    # update: List['TriageNoteUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TriageNoteUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TriageNoteScalarWhereInput']
    # upsert: List['TriageNoteUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['TriageNoteCreateOrConnectWithoutRelationsInput']


class TriageNoteUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TriageNoteCreateWithoutRelationsInput'
    connect: 'TriageNoteWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TriageNoteUpdateInput'
    # upsert: 'TriageNoteUpsertWithoutRelationsInput'
    # connectOrCreate: 'TriageNoteCreateOrConnectWithoutRelationsInput'


class TriageNoteUpsertInput(TypedDict):
    create: 'TriageNoteCreateInput'
    update: 'TriageNoteUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_TriageNote_id_OrderByInput = TypedDict(
    '_TriageNote_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_TriageNote_userId_OrderByInput = TypedDict(
    '_TriageNote_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_TriageNote_predictionId_OrderByInput = TypedDict(
    '_TriageNote_predictionId_OrderByInput',
    {
        'predictionId': 'SortOrder',
    },
    total=True
)

_TriageNote_complaint_OrderByInput = TypedDict(
    '_TriageNote_complaint_OrderByInput',
    {
        'complaint': 'SortOrder',
    },
    total=True
)

_TriageNote_triageSummary_OrderByInput = TypedDict(
    '_TriageNote_triageSummary_OrderByInput',
    {
        'triageSummary': 'SortOrder',
    },
    total=True
)

_TriageNote_followups_OrderByInput = TypedDict(
    '_TriageNote_followups_OrderByInput',
    {
        'followups': 'SortOrder',
    },
    total=True
)

_TriageNote_modelName_OrderByInput = TypedDict(
    '_TriageNote_modelName_OrderByInput',
    {
        'modelName': 'SortOrder',
    },
    total=True
)

_TriageNote_createdAt_OrderByInput = TypedDict(
    '_TriageNote_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

TriageNoteOrderByInput = Union[
    '_TriageNote_id_OrderByInput',
    '_TriageNote_userId_OrderByInput',
    '_TriageNote_predictionId_OrderByInput',
    '_TriageNote_complaint_OrderByInput',
    '_TriageNote_triageSummary_OrderByInput',
    '_TriageNote_followups_OrderByInput',
    '_TriageNote_modelName_OrderByInput',
    '_TriageNote_createdAt_OrderByInput',
]



# recursive TriageNote types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

TriageNoteRelationFilter = TypedDict(
    'TriageNoteRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class TriageNoteListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class TriageNoteInclude(TypedDict, total=False):
    """TriageNote relational arguments"""
    Prediction: Union[bool, 'PredictionArgsFromTriageNote']
    Profile: Union[bool, 'ProfileArgsFromTriageNote']


    

class ProfileIncludeFromTriageNote(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Reports: Union[bool, 'FindManyReportArgsFromTriageNoteRecursive1']
    Predictions: Union[bool, 'FindManyPredictionArgsFromTriageNoteRecursive1']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromTriageNoteRecursive1']


class ProfileIncludeFromTriageNoteRecursive1(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Reports: Union[bool, 'FindManyReportArgsFromTriageNoteRecursive2']
    Predictions: Union[bool, 'FindManyPredictionArgsFromTriageNoteRecursive2']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromTriageNoteRecursive2']


class ProfileIncludeFromTriageNoteRecursive2(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Reports: Union[bool, 'FindManyReportArgsFromTriageNoteRecursive3']
    Predictions: Union[bool, 'FindManyPredictionArgsFromTriageNoteRecursive3']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromTriageNoteRecursive3']


class ProfileIncludeFromTriageNoteRecursive3(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Reports: Union[bool, 'FindManyReportArgsFromTriageNoteRecursive4']
    Predictions: Union[bool, 'FindManyPredictionArgsFromTriageNoteRecursive4']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromTriageNoteRecursive4']


class ProfileIncludeFromTriageNoteRecursive4(TypedDict, total=False):
    """Relational arguments for TriageNote"""

    

class ProfileArgsFromTriageNote(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'ProfileIncludeFromProfileRecursive1'


class ProfileArgsFromTriageNoteRecursive1(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'ProfileIncludeFromProfileRecursive2'


class ProfileArgsFromTriageNoteRecursive2(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'ProfileIncludeFromProfileRecursive3'


class ProfileArgsFromTriageNoteRecursive3(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'ProfileIncludeFromProfileRecursive4'


class ProfileArgsFromTriageNoteRecursive4(TypedDict, total=False):
    """Arguments for TriageNote"""
    
    

class FindManyProfileArgsFromTriageNote(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive1'


class FindManyProfileArgsFromTriageNoteRecursive1(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive2'


class FindManyProfileArgsFromTriageNoteRecursive2(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive3'


class FindManyProfileArgsFromTriageNoteRecursive3(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfileRecursive4'


class FindManyProfileArgsFromTriageNoteRecursive4(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    
    

class ReportIncludeFromTriageNote(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromTriageNoteRecursive1']
    Profile: Union[bool, 'ProfileArgsFromTriageNoteRecursive1']


class ReportIncludeFromTriageNoteRecursive1(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromTriageNoteRecursive2']
    Profile: Union[bool, 'ProfileArgsFromTriageNoteRecursive2']


class ReportIncludeFromTriageNoteRecursive2(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromTriageNoteRecursive3']
    Profile: Union[bool, 'ProfileArgsFromTriageNoteRecursive3']


class ReportIncludeFromTriageNoteRecursive3(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Predictions: Union[bool, 'FindManyPredictionArgsFromTriageNoteRecursive4']
    Profile: Union[bool, 'ProfileArgsFromTriageNoteRecursive4']


class ReportIncludeFromTriageNoteRecursive4(TypedDict, total=False):
    """Relational arguments for TriageNote"""

    

class ReportArgsFromTriageNote(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'ReportIncludeFromReportRecursive1'


class ReportArgsFromTriageNoteRecursive1(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'ReportIncludeFromReportRecursive2'


class ReportArgsFromTriageNoteRecursive2(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'ReportIncludeFromReportRecursive3'


class ReportArgsFromTriageNoteRecursive3(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'ReportIncludeFromReportRecursive4'


class ReportArgsFromTriageNoteRecursive4(TypedDict, total=False):
    """Arguments for TriageNote"""
    
    

class FindManyReportArgsFromTriageNote(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive1'


class FindManyReportArgsFromTriageNoteRecursive1(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive2'


class FindManyReportArgsFromTriageNoteRecursive2(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive3'


class FindManyReportArgsFromTriageNoteRecursive3(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    include: 'ReportIncludeFromReportRecursive4'


class FindManyReportArgsFromTriageNoteRecursive4(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['ReportOrderByInput', List['ReportOrderByInput']]
    where: 'ReportWhereInput'
    cursor: 'ReportWhereUniqueInput'
    distinct: List['ReportScalarFieldKeys']
    
    

class PredictionIncludeFromTriageNote(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Report: Union[bool, 'ReportArgsFromTriageNoteRecursive1']
    Profile: Union[bool, 'ProfileArgsFromTriageNoteRecursive1']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromTriageNoteRecursive1']


class PredictionIncludeFromTriageNoteRecursive1(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Report: Union[bool, 'ReportArgsFromTriageNoteRecursive2']
    Profile: Union[bool, 'ProfileArgsFromTriageNoteRecursive2']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromTriageNoteRecursive2']


class PredictionIncludeFromTriageNoteRecursive2(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Report: Union[bool, 'ReportArgsFromTriageNoteRecursive3']
    Profile: Union[bool, 'ProfileArgsFromTriageNoteRecursive3']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromTriageNoteRecursive3']


class PredictionIncludeFromTriageNoteRecursive3(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Report: Union[bool, 'ReportArgsFromTriageNoteRecursive4']
    Profile: Union[bool, 'ProfileArgsFromTriageNoteRecursive4']
    TriageNotes: Union[bool, 'FindManyTriageNoteArgsFromTriageNoteRecursive4']


class PredictionIncludeFromTriageNoteRecursive4(TypedDict, total=False):
    """Relational arguments for TriageNote"""

    

class PredictionArgsFromTriageNote(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'PredictionIncludeFromPredictionRecursive1'


class PredictionArgsFromTriageNoteRecursive1(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'PredictionIncludeFromPredictionRecursive2'


class PredictionArgsFromTriageNoteRecursive2(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'PredictionIncludeFromPredictionRecursive3'


class PredictionArgsFromTriageNoteRecursive3(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'PredictionIncludeFromPredictionRecursive4'


class PredictionArgsFromTriageNoteRecursive4(TypedDict, total=False):
    """Arguments for TriageNote"""
    
    

class FindManyPredictionArgsFromTriageNote(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive1'


class FindManyPredictionArgsFromTriageNoteRecursive1(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive2'


class FindManyPredictionArgsFromTriageNoteRecursive2(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive3'


class FindManyPredictionArgsFromTriageNoteRecursive3(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    include: 'PredictionIncludeFromPredictionRecursive4'


class FindManyPredictionArgsFromTriageNoteRecursive4(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['PredictionOrderByInput', List['PredictionOrderByInput']]
    where: 'PredictionWhereInput'
    cursor: 'PredictionWhereUniqueInput'
    distinct: List['PredictionScalarFieldKeys']
    
    

class TriageNoteIncludeFromTriageNote(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Prediction: Union[bool, 'PredictionArgsFromTriageNoteRecursive1']
    Profile: Union[bool, 'ProfileArgsFromTriageNoteRecursive1']


class TriageNoteIncludeFromTriageNoteRecursive1(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Prediction: Union[bool, 'PredictionArgsFromTriageNoteRecursive2']
    Profile: Union[bool, 'ProfileArgsFromTriageNoteRecursive2']


class TriageNoteIncludeFromTriageNoteRecursive2(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Prediction: Union[bool, 'PredictionArgsFromTriageNoteRecursive3']
    Profile: Union[bool, 'ProfileArgsFromTriageNoteRecursive3']


class TriageNoteIncludeFromTriageNoteRecursive3(TypedDict, total=False):
    """Relational arguments for TriageNote"""
    Prediction: Union[bool, 'PredictionArgsFromTriageNoteRecursive4']
    Profile: Union[bool, 'ProfileArgsFromTriageNoteRecursive4']


class TriageNoteIncludeFromTriageNoteRecursive4(TypedDict, total=False):
    """Relational arguments for TriageNote"""

    

class TriageNoteArgsFromTriageNote(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive1'


class TriageNoteArgsFromTriageNoteRecursive1(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive2'


class TriageNoteArgsFromTriageNoteRecursive2(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive3'


class TriageNoteArgsFromTriageNoteRecursive3(TypedDict, total=False):
    """Arguments for TriageNote"""
    include: 'TriageNoteIncludeFromTriageNoteRecursive4'


class TriageNoteArgsFromTriageNoteRecursive4(TypedDict, total=False):
    """Arguments for TriageNote"""
    
    

class FindManyTriageNoteArgsFromTriageNote(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive1'


class FindManyTriageNoteArgsFromTriageNoteRecursive1(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive2'


class FindManyTriageNoteArgsFromTriageNoteRecursive2(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive3'


class FindManyTriageNoteArgsFromTriageNoteRecursive3(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    include: 'TriageNoteIncludeFromTriageNoteRecursive4'


class FindManyTriageNoteArgsFromTriageNoteRecursive4(TypedDict, total=False):
    """Arguments for TriageNote"""
    take: int
    skip: int
    order_by: Union['TriageNoteOrderByInput', List['TriageNoteOrderByInput']]
    where: 'TriageNoteWhereInput'
    cursor: 'TriageNoteWhereUniqueInput'
    distinct: List['TriageNoteScalarFieldKeys']
    


FindManyTriageNoteArgs = FindManyTriageNoteArgsFromTriageNote
FindFirstTriageNoteArgs = FindManyTriageNoteArgsFromTriageNote


    

class TriageNoteWhereInput(TypedDict, total=False):
    """TriageNote arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    predictionId: Union[_str, 'types.StringFilter']
    complaint: Union[None, _str, 'types.StringFilter']
    triageSummary: Union[_str, 'types.StringFilter']
    followups: Union['fields.Json', 'types.JsonFilter']
    modelName: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Prediction: 'PredictionRelationFilter'
    Profile: 'ProfileRelationFilter'

    # should be noted that AND and NOT should be Union['TriageNoteWhereInputRecursive1', List['TriageNoteWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['TriageNoteWhereInputRecursive1']
    OR: List['TriageNoteWhereInputRecursive1']
    NOT: List['TriageNoteWhereInputRecursive1']


class TriageNoteWhereInputRecursive1(TypedDict, total=False):
    """TriageNote arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    predictionId: Union[_str, 'types.StringFilter']
    complaint: Union[None, _str, 'types.StringFilter']
    triageSummary: Union[_str, 'types.StringFilter']
    followups: Union['fields.Json', 'types.JsonFilter']
    modelName: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Prediction: 'PredictionRelationFilter'
    Profile: 'ProfileRelationFilter'

    # should be noted that AND and NOT should be Union['TriageNoteWhereInputRecursive2', List['TriageNoteWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['TriageNoteWhereInputRecursive2']
    OR: List['TriageNoteWhereInputRecursive2']
    NOT: List['TriageNoteWhereInputRecursive2']


class TriageNoteWhereInputRecursive2(TypedDict, total=False):
    """TriageNote arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    predictionId: Union[_str, 'types.StringFilter']
    complaint: Union[None, _str, 'types.StringFilter']
    triageSummary: Union[_str, 'types.StringFilter']
    followups: Union['fields.Json', 'types.JsonFilter']
    modelName: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Prediction: 'PredictionRelationFilter'
    Profile: 'ProfileRelationFilter'

    # should be noted that AND and NOT should be Union['TriageNoteWhereInputRecursive3', List['TriageNoteWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['TriageNoteWhereInputRecursive3']
    OR: List['TriageNoteWhereInputRecursive3']
    NOT: List['TriageNoteWhereInputRecursive3']


class TriageNoteWhereInputRecursive3(TypedDict, total=False):
    """TriageNote arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    predictionId: Union[_str, 'types.StringFilter']
    complaint: Union[None, _str, 'types.StringFilter']
    triageSummary: Union[_str, 'types.StringFilter']
    followups: Union['fields.Json', 'types.JsonFilter']
    modelName: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Prediction: 'PredictionRelationFilter'
    Profile: 'ProfileRelationFilter'

    # should be noted that AND and NOT should be Union['TriageNoteWhereInputRecursive4', List['TriageNoteWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['TriageNoteWhereInputRecursive4']
    OR: List['TriageNoteWhereInputRecursive4']
    NOT: List['TriageNoteWhereInputRecursive4']


class TriageNoteWhereInputRecursive4(TypedDict, total=False):
    """TriageNote arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    predictionId: Union[_str, 'types.StringFilter']
    complaint: Union[None, _str, 'types.StringFilter']
    triageSummary: Union[_str, 'types.StringFilter']
    followups: Union['fields.Json', 'types.JsonFilter']
    modelName: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    Prediction: 'PredictionRelationFilter'
    Profile: 'ProfileRelationFilter'



# aggregate TriageNote types


    

class TriageNoteScalarWhereWithAggregatesInput(TypedDict, total=False):
    """TriageNote arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    predictionId: Union[_str, 'types.StringWithAggregatesFilter']
    complaint: Union[_str, 'types.StringWithAggregatesFilter']
    triageSummary: Union[_str, 'types.StringWithAggregatesFilter']
    followups: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    modelName: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TriageNoteScalarWhereWithAggregatesInputRecursive1']
    OR: List['TriageNoteScalarWhereWithAggregatesInputRecursive1']
    NOT: List['TriageNoteScalarWhereWithAggregatesInputRecursive1']


class TriageNoteScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """TriageNote arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    predictionId: Union[_str, 'types.StringWithAggregatesFilter']
    complaint: Union[_str, 'types.StringWithAggregatesFilter']
    triageSummary: Union[_str, 'types.StringWithAggregatesFilter']
    followups: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    modelName: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TriageNoteScalarWhereWithAggregatesInputRecursive2']
    OR: List['TriageNoteScalarWhereWithAggregatesInputRecursive2']
    NOT: List['TriageNoteScalarWhereWithAggregatesInputRecursive2']


class TriageNoteScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """TriageNote arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    predictionId: Union[_str, 'types.StringWithAggregatesFilter']
    complaint: Union[_str, 'types.StringWithAggregatesFilter']
    triageSummary: Union[_str, 'types.StringWithAggregatesFilter']
    followups: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    modelName: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TriageNoteScalarWhereWithAggregatesInputRecursive3']
    OR: List['TriageNoteScalarWhereWithAggregatesInputRecursive3']
    NOT: List['TriageNoteScalarWhereWithAggregatesInputRecursive3']


class TriageNoteScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """TriageNote arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    predictionId: Union[_str, 'types.StringWithAggregatesFilter']
    complaint: Union[_str, 'types.StringWithAggregatesFilter']
    triageSummary: Union[_str, 'types.StringWithAggregatesFilter']
    followups: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    modelName: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TriageNoteScalarWhereWithAggregatesInputRecursive4']
    OR: List['TriageNoteScalarWhereWithAggregatesInputRecursive4']
    NOT: List['TriageNoteScalarWhereWithAggregatesInputRecursive4']


class TriageNoteScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """TriageNote arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    predictionId: Union[_str, 'types.StringWithAggregatesFilter']
    complaint: Union[_str, 'types.StringWithAggregatesFilter']
    triageSummary: Union[_str, 'types.StringWithAggregatesFilter']
    followups: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    modelName: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class TriageNoteGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    predictionId: _str
    complaint: _str
    triageSummary: _str
    followups: 'fields.Json'
    modelName: _str
    createdAt: datetime.datetime
    _sum: 'TriageNoteSumAggregateOutput'
    _avg: 'TriageNoteAvgAggregateOutput'
    _min: 'TriageNoteMinAggregateOutput'
    _max: 'TriageNoteMaxAggregateOutput'
    _count: 'TriageNoteCountAggregateOutput'


class TriageNoteAvgAggregateOutput(TypedDict, total=False):
    """TriageNote output for aggregating averages"""


class TriageNoteSumAggregateOutput(TypedDict, total=False):
    """TriageNote output for aggregating sums"""


class TriageNoteScalarAggregateOutput(TypedDict, total=False):
    """TriageNote output including scalar fields"""
    id: _str
    userId: _str
    predictionId: _str
    complaint: _str
    triageSummary: _str
    followups: 'fields.Json'
    modelName: _str
    createdAt: datetime.datetime


TriageNoteMinAggregateOutput = TriageNoteScalarAggregateOutput
TriageNoteMaxAggregateOutput = TriageNoteScalarAggregateOutput


class TriageNoteMaxAggregateInput(TypedDict, total=False):
    """TriageNote input for aggregating by max"""
    id: bool
    userId: bool
    predictionId: bool
    complaint: bool
    triageSummary: bool
    followups: bool
    modelName: bool
    createdAt: bool


class TriageNoteMinAggregateInput(TypedDict, total=False):
    """TriageNote input for aggregating by min"""
    id: bool
    userId: bool
    predictionId: bool
    complaint: bool
    triageSummary: bool
    followups: bool
    modelName: bool
    createdAt: bool


class TriageNoteNumberAggregateInput(TypedDict, total=False):
    """TriageNote input for aggregating numbers"""


TriageNoteAvgAggregateInput = TriageNoteNumberAggregateInput
TriageNoteSumAggregateInput = TriageNoteNumberAggregateInput


TriageNoteCountAggregateInput = TypedDict(
    'TriageNoteCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'predictionId': bool,
        'complaint': bool,
        'triageSummary': bool,
        'followups': bool,
        'modelName': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

TriageNoteCountAggregateOutput = TypedDict(
    'TriageNoteCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'predictionId': int,
        'complaint': int,
        'triageSummary': int,
        'followups': int,
        'modelName': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


TriageNoteKeys = Literal[
    'id',
    'userId',
    'predictionId',
    'complaint',
    'triageSummary',
    'followups',
    'modelName',
    'createdAt',
    'Prediction',
    'Profile',
]
TriageNoteScalarFieldKeys = Literal[
    'id',
    'userId',
    'predictionId',
    'complaint',
    'triageSummary',
    'followups',
    'modelName',
    'createdAt',
]
TriageNoteScalarFieldKeysT = TypeVar('TriageNoteScalarFieldKeysT', bound=TriageNoteScalarFieldKeys)

TriageNoteRelationalFieldKeys = Literal[
        'Prediction',
        'Profile',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields